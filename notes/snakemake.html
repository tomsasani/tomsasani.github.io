<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.34">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>An introduction to Snakemake for pipeline management – Tom Sasani</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-c8ad9e5dbd60b7b70b38521ab19b7da4.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-11019d9a91a35b65a50b828feba9fcb9.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Tom Sasani</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../pubs.html"> 
<span class="menu-text">Publications</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../talks.html"> 
<span class="menu-text">Talks</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../teaching.html"> 
<span class="menu-text">Teaching</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-research-notes" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Research notes</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-research-notes">    
        <li>
    <a class="dropdown-item" href="../notes/tiny_transformers.html">
 <span class="dropdown-text">Tiny transformers for population genetic inference</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../vitae/resume.pdf"> 
<span class="menu-text">CV</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/tomsasani"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/tomsasani"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#motivation" id="toc-motivation" class="nav-link active" data-scroll-target="#motivation">Motivation</a></li>
  <li><a href="#every-step-of-the-pipeline-gets-its-own-rule" id="toc-every-step-of-the-pipeline-gets-its-own-rule" class="nav-link" data-scroll-target="#every-step-of-the-pipeline-gets-its-own-rule">Every step of the pipeline gets its own “rule”</a></li>
  <li><a href="#snakemake-will-only-run-a-rule-if-it-has-to" id="toc-snakemake-will-only-run-a-rule-if-it-has-to" class="nav-link" data-scroll-target="#snakemake-will-only-run-a-rule-if-it-has-to">Snakemake will only run a rule if it has to</a></li>
  <li><a href="#using-wildcards-to-avoid-re-writing-the-same-command-over-and-over-again" id="toc-using-wildcards-to-avoid-re-writing-the-same-command-over-and-over-again" class="nav-link" data-scroll-target="#using-wildcards-to-avoid-re-writing-the-same-command-over-and-over-again">Using wildcards to avoid re-writing the same command over and over again</a></li>
  <li><a href="#using-expand-to-run-a-pipeline-on-many-samples-or-with-many-parameters" id="toc-using-expand-to-run-a-pipeline-on-many-samples-or-with-many-parameters" class="nav-link" data-scroll-target="#using-expand-to-run-a-pipeline-on-many-samples-or-with-many-parameters">Using <code>expand</code> to run a pipeline on many samples or with many parameters</a></li>
  <li><a href="#including-pure-python-in-a-rule" id="toc-including-pure-python-in-a-rule" class="nav-link" data-scroll-target="#including-pure-python-in-a-rule">Including pure python in a rule</a></li>
  <li><a href="#running-a-snakemake-pipeline-on-the-sage-grid-engine-sge" id="toc-running-a-snakemake-pipeline-on-the-sage-grid-engine-sge" class="nav-link" data-scroll-target="#running-a-snakemake-pipeline-on-the-sage-grid-engine-sge">Running a Snakemake pipeline on the Sage Grid Engine (SGE)</a></li>
  <li><a href="#using-a-config-file-to-flexibly-change-grid-requirements-for-particular-rules" id="toc-using-a-config-file-to-flexibly-change-grid-requirements-for-particular-rules" class="nav-link" data-scroll-target="#using-a-config-file-to-flexibly-change-grid-requirements-for-particular-rules">Using a config file to flexibly change grid requirements for particular rules</a></li>
  <li><a href="#visualizing-the-full-pipeline-with-a-dag" id="toc-visualizing-the-full-pipeline-with-a-dag" class="nav-link" data-scroll-target="#visualizing-the-full-pipeline-with-a-dag">Visualizing the full pipeline with a DAG</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">An introduction to Snakemake for pipeline management</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>A quick-start guide for Snakemake</p>
<section id="motivation" class="level2">
<h2 class="anchored" data-anchor-id="motivation">Motivation</h2>
<p>There are few (if any) scientific questions that you can answer by running a single program or script. Calling variants involves aligning reads, sorting reads, indexing reads, running a variant caller, filtering those calls, etc. Running a simulation will inevitably require changing parameters or including new combinations of those parameters.</p>
<p>And there are few (if any) programs or scripts that will run/compile correctly on the first try, due to either user error, code bugs, dependency conflicts, improperly configured environments, or any combination therein.</p>
<p>For these reasons, it’s often crucial to package the various steps of your analysis into a “pipeline.” Ideally, this pipeline would accept a file(s) as input, do some stuff with that file, and generate an output file(s). For example, your pipeline might take a FASTQ file and reference genome FASTA as input, and output an aligned, sorted, and indexed BAM.</p>
<p>In theory, a pipeline could just be a Bash script in which you enumerate each step of the process. But what if you want to run the pipeline on hundreds of samples’ FASTQ files? And what if the final step in your Bash script fails? <strong>You’ll have to re-run the entire pipeline all over again.</strong></p>
<p>This is where Snakemake comes in. Snakemake is a flexible Python-based pipeline manager, and it’s even tuned for running on the Sage Grid Engine (or pretty much any other compute environment).</p>
<blockquote class="blockquote">
<p>As an example, let’s imagine that we want to take paired-end FASTQ from 3 different mouse samples (A, B, and C) and generate a preliminary set of variant calls for each sample.</p>
</blockquote>
<blockquote class="blockquote">
<p>To start, let’s imagine we only want to process one sample: A.</p>
</blockquote>
</section>
<section id="every-step-of-the-pipeline-gets-its-own-rule" class="level2">
<h2 class="anchored" data-anchor-id="every-step-of-the-pipeline-gets-its-own-rule">Every step of the pipeline gets its own “rule”</h2>
<p>The first step of the pipeline will be to download an <em>M. musculus</em> reference genome so that we can align reads.</p>
<pre><code>rule download_reference:
  input:
  output:
    "GRCm38.primary_assembly.genome.fa.gz"
  shell:
    """
    wget ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_mouse/release_M10/GRCm38.primary_assembly.genome.fa.gz
    """</code></pre>
<blockquote class="blockquote">
<p>This rule, which is named <code>download_reference</code>, doesn’t take any input, since it’s just downloading a FASTA directly.</p>
</blockquote>
<blockquote class="blockquote">
<p>We specify that the expected output of this rule is a single gzipped FASTA.</p>
</blockquote>
<blockquote class="blockquote">
<p>After <code>shell:</code>, we simply list the commands we’d normally type at the command line to produce the specified output. These commands can be wrapped up in a docstring for easy formatting.</p>
</blockquote>
<p>Next, we want to align the FASTQ data from sample A to the reference.</p>
<pre><code>rule bwa_align:
  input:
    ref = "GRCm38.primary_assembly.genome.fa.gz",
    fq1 = "A_1.fastq.gz",
    fq2 = "A_2.fastq.gz"
  output:
    "A.sorted.bam"
  shell:
    """
    bwa mem -t 4 {input.ref} {input.fq1} {input.fq2} | sambamba view -S -f bam /dev/stdin | sambamba sort -o {output} /dev/stdin
    """</code></pre>
<blockquote class="blockquote">
<p>This rule takes as input a reference genome and two FASTQ files. As you can see, it’s possible to name individual input or output files (using Python variable assignment) so that we can access particular files in our shell command.</p>
</blockquote>
<blockquote class="blockquote">
<p>Note that if a rule has more than one input (or output) files, they should be comma-separated.</p>
</blockquote>
</section>
<section id="snakemake-will-only-run-a-rule-if-it-has-to" class="level2">
<h2 class="anchored" data-anchor-id="snakemake-will-only-run-a-rule-if-it-has-to">Snakemake will only run a rule if it has to</h2>
<p>Let’s take a look at the full pipeline we’ve defined so far.</p>
<pre><code>rule all:
  input:
    "A.sorted.bam"

rule download_reference:
  input:
  output:
    "GRCm38.primary_assembly.genome.fa.gz"
  shell:
    """
    wget ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_mouse/release_M10/GRCm38.primary_assembly.genome.fa.gz
    """

rule bwa_align:
  input:
    ref = "GRCm38.primary_assembly.genome.fa.gz",
    fq1 = "A_1.fastq.gz",
    fq2 = "A_2.fastq.gz"
  output:
    "A.sorted.bam"
  shell:
    """
    bwa mem -t 4 {input.ref} {input.fq1} {input.fq2} | sambamba view -S -f bam /dev/stdin | sambamba sort -o {output} /dev/stdin
    """</code></pre>
<blockquote class="blockquote">
<p><strong>A huge advantage of Snakemake is that it will only run a rule if its output is needed by a downstream rule.</strong></p>
</blockquote>
<blockquote class="blockquote">
<p>You can see that I’ve added a rule (called <code>all</code>) to the top of the pipeline. This is because Snakemake runs in a “bottom-up” fashion.</p>
</blockquote>
<blockquote class="blockquote">
<p>The <code>all</code> rule tells Snakemake what the final output of the entire pipeline should be. In this case, we want the final output to be an aligned BAM.</p>
</blockquote>
<blockquote class="blockquote">
<p>In this example, Snakemake finds the rule that outputs <code>A.sorted.bam</code> (which is <code>bwa_align</code>), and checks to see if that rule has access to all of its necessary inputs (a reference and two FASTQ files). If not, Snakemake finds the rules that produce those files and runs them. And so on. Once <code>bwa_align</code> has all of the inputs it needs, Snakemake runs it to produce the final output.</p>
</blockquote>
<blockquote class="blockquote">
<p>And let’s say that for whatever reason, <code>bwa_align</code> fails when its run. When we re-run the pipeline, Snakemake will check that its input files are present. Since all of the previous rules will have been run before invoking <code>bwa_align</code>, Snakemake will see that its inputs are present and won’t re-run any of the upstream steps!</p>
</blockquote>
</section>
<section id="using-wildcards-to-avoid-re-writing-the-same-command-over-and-over-again" class="level2">
<h2 class="anchored" data-anchor-id="using-wildcards-to-avoid-re-writing-the-same-command-over-and-over-again">Using wildcards to avoid re-writing the same command over and over again</h2>
<p>In the previous example, we were only running the pipeline on a single sample. But to generalize the pipeline to run on any list of samples, we can make use of the <code>expand</code> feature, as well as Snakemake “wildcards.”</p>
<p>Were this a bash pipeline we’d have to write out a separate set of commands for every sample. But with Snakemake it’s much easier.</p>
<p>Here’s an example of what our pipeline would look like with wildcard placeholders instead of explicit sample names.</p>
<pre><code>samples = ["A", "B", "C"]

rule all:
  input:
    expand("{sample}.sorted.bam", sample=samples)

rule download_reference:
  input: 
  output:
    "GRCm38.primary_assembly.genome.fa.gz"
  shell:
    """
    wget ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_mouse/release_M10/GRCm38.primary_assembly.genome.fa.gz
    """

rule bwa_align:
  input: 
    ref = "GRCm38.primary_assembly.genome.fa.gz",
    fq1 = "{sample}_1.fastq.gz",
    fq2 = "{sample}_2.fastq.gz"
  output:
    "{sample}.sorted.bam"
  shell:
    """
    bwa mem -t 4 {input.ref} {input.fq1} {input.fq2} | sambamba view -S -f bam /dev/stdin | sambamba sort -o {output} /dev/stdin
    """</code></pre>
<blockquote class="blockquote">
<p>Here, I’ve just replaced every instance of a sample name in an output or input file with a <code>{sample}</code> wildcard.</p>
</blockquote>
<blockquote class="blockquote">
<p>In the <code>all</code> rule, I’m using the <code>expand</code> function to tell Snakemake that the expected output is a list of sorted BAMs, with the sample names in <code>samples</code> filled in.</p>
</blockquote>
<p>In this case, the result of the <code>expand</code> would just be:</p>
<pre><code>&gt;&gt;&gt; expand("{sample}.sorted.bam", sample=samples)

["A.sorted.bam", "B.sorted.bam", "C.sorted.bam"]</code></pre>
<p>But we can also use <code>expand</code> for more complicated chaining of multiple sample names and parameters.</p>
</section>
<section id="using-expand-to-run-a-pipeline-on-many-samples-or-with-many-parameters" class="level2">
<h2 class="anchored" data-anchor-id="using-expand-to-run-a-pipeline-on-many-samples-or-with-many-parameters">Using <code>expand</code> to run a pipeline on many samples or with many parameters</h2>
<p>Let’s say that once we’ve produced aligned and sorted BAMs, we want to then run a simple variant calling program on each sample’s alignments.</p>
<p>To speed up execution of the variant calling pipeline, it might help to parallelize our pipeline to run on every chromosome separately.</p>
<p>To do this, we’ll again make use of <code>expand</code>.</p>
<pre><code>samples = ["A", "B", "C"]

chromosomes = list(range(1, 20))
chromosomes = list(map(str, chromosomes))
chromosomes.extend(['X', 'Y'])

rule all:
  input:
    expand("{sample}.{chrom}.vcf", sample=samples, chrom=chromosomes)

rule download_reference:
  input: 
  output:
    "GRCm38.primary_assembly.genome.fa.gz"
  shell:
    """
    wget ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_mouse/release_M10/GRCm38.primary_assembly.genome.fa.gz
    """

rule bwa_align:
  input: 
    ref = "GRCm38.primary_assembly.genome.fa.gz",
    fq1 = "{sample}_1.fastq.gz",
    fq2 = "{sample}_2.fastq.gz"
  output:
    "{sample}.sorted.bam"
  shell:
    """
    bwa mem -t 4 {input.ref} {input.fq1} {input.fq2} | sambamba view -S -f bam /dev/stdin | sambamba sort -o {output} /dev/stdin
    """

rule call_variants:
  input:
    ref = "GRCm38.primary_assembly.genome.fa.gz",
    bam = "{sample}.sorted.bam"
  output:
    "{sample}.{chrom}.vcf"
  shell:
    """
    freebayes -f {input.ref} -r {wildcards.chrom} {input.bam} &gt; {output}
    """</code></pre>
<blockquote class="blockquote">
<p>We’ve now added a step to the pipeline which takes a reference genome and a BAM as input, and outputs a variant call file (VCF).</p>
</blockquote>
<blockquote class="blockquote">
<p>Notice that in the <code>call_variants</code> rule, my <code>freebayes</code> command takes a <code>-r</code> argument that specifies the region we want to analyze. Whenever you want to access a wildcard inside of the <code>shell:</code> portion of a rule, its necessary to preface the wildcard name with <code>wildcard</code>.</p>
</blockquote>
<p>And in this example, <code>expand</code> takes the Cartesian product (i.e., <code>itertools.product()</code>) of the lists of parameters. So, the output of <code>expand</code> would be:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> expand(<span class="st">"</span><span class="sc">{sample}</span><span class="st">.</span><span class="sc">{chrom}</span><span class="st">.vcf"</span>, sample<span class="op">=</span>samples, chrom<span class="op">=</span>chromosomes)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>[<span class="st">"A.chr1.vcf"</span>,</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a> <span class="st">"A.chr2.vcf"</span>,</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a> <span class="st">"A.chr3.vcf"</span>,</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a> ...</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a> <span class="st">"C.chrY.vcf"</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This way, we can enumerate every possible combination of input parameters instead of typing out 3 * 21 separate commands.</p>
</section>
<section id="including-pure-python-in-a-rule" class="level2">
<h2 class="anchored" data-anchor-id="including-pure-python-in-a-rule">Including pure python in a rule</h2>
<p>So far, our rules have only invoked shell commands like <code>bwa</code> or <code>wget</code>. But Snakemake also allows you to make a rule that is just a block of python code. For example, the following rule would be totally acceptable.</p>
<pre><code>rule count_snps:
  input:
    expand("{sample}.{chrom}.vcf", sample=samples, chrom=chromosomes)
  output:
    "per_sample.snp_counts.tsv"
  run:
    """
    from cyvcf2 import VCF

    vcf_file = VCF({input})

    output_fh = open({output}, "w")
    
    # loop over input files
    for vcf_fh in {input}:

      sample_name = vcf_fh.split('.')[0]
      chrom = vcf_fh.split('.')[1]

      # initialize a VCF object using each
      # file handle in the input list
      vcf = VCF(vcf_fh)

      snp_count = 0

      for v in vcf:
        if v.var_type == "snp": snp_count += 1

      print (','.join([sample_name, chrom, str(snp_count)]), file=output_fh)

    """</code></pre>
<blockquote class="blockquote">
<p><strong>Notice that when a rule includes python code, we use the <code>run:</code> syntax instead of the <code>shell:</code> syntax at the top of the code block.</strong></p>
</blockquote>
</section>
<section id="running-a-snakemake-pipeline-on-the-sage-grid-engine-sge" class="level2">
<h2 class="anchored" data-anchor-id="running-a-snakemake-pipeline-on-the-sage-grid-engine-sge">Running a Snakemake pipeline on the Sage Grid Engine (SGE)</h2>
<p>In our lab, we use the SGE to submit and manage compute jobs on the cluster. Snakemake is actually compatible with SGE (and SLURM, etc.), which makes it super easy to submit jobs to SGE directly from a Snakemake pipeline.</p>
<p>As an example, we could execute our pipeline as follows:</p>
<pre><code>snakemake -j 10 \
      --cluster \
      --rerun-incomplete \
       "qsub -l centos=7 -l mfree=16G -l h_rt=12:0:0 -o /path/to/outdir -e /path/to/errdir"</code></pre>
<blockquote class="blockquote">
<p>The <code>-j</code> flag specifies the maximum number of jobs Snakemake is allowed to submit to SGE at a time.</p>
</blockquote>
<blockquote class="blockquote">
<p>The <code>--rerun-incomplete</code> flag is awesome. If we run our pipeline and it fails for some reason, using <code>--rerun-incomplete</code> will tell Snakemake to re-run a rule if the output of that rule is incomplete (i.e., if the rule didn’t finish due to a job failure in the last pipeline execution).</p>
</blockquote>
<blockquote class="blockquote">
<p>After specifying <code>--cluster</code>, we just put the normal <code>qsub</code> command we’d normally use to submit a <code>.sh</code> or <code>.sge</code> script to the cluster, specifying the memory required by each job, wall time, etc.</p>
</blockquote>
</section>
<section id="using-a-config-file-to-flexibly-change-grid-requirements-for-particular-rules" class="level2">
<h2 class="anchored" data-anchor-id="using-a-config-file-to-flexibly-change-grid-requirements-for-particular-rules">Using a config file to flexibly change grid requirements for particular rules</h2>
<p>One natural issue with the above command is that some rules might require different cluster specifications than others.</p>
<p>For example, I’ve written my <code>bwa_align</code> rule such that <code>bwa mem</code> will use 4 threads during alignment, and it’ll probably use much more memory than downloading a reference genome.</p>
<p>Thankfully, Snakemake lets us create individual cluster specifications for each of our rules using a <code>config</code> file. See the example <code>config</code> file below, which is written in JSON.</p>
<pre><code>"__default__":

{ "memory": "8G",
  "time": "1:0:0",
  "threads": "1",
  "os": "7" },

"bwa_align":

{ "memory": "4G",
  "time": "8:0:0",
  "threads": "4",
  "os": "7" }</code></pre>
<p>Then, when we run Snakemake, we could do the following:</p>
<pre><code>snakemake -j 10 \
      --cluster-config /path/to/config.json \
      --cluster \
      --rerun-incomplete \
      "qsub -l centos={cluster.os} -l mfree={cluster.memory} -l h_rt={cluster.time} -pe serial {cluster.threads}"</code></pre>
</section>
<section id="visualizing-the-full-pipeline-with-a-dag" class="level2">
<h2 class="anchored" data-anchor-id="visualizing-the-full-pipeline-with-a-dag">Visualizing the full pipeline with a DAG</h2>
<p>We can also visualize the various steps of the pipeline in a directed acyclic graph (DAG).</p>
<p>After putting the full pipeline in a file called <code>Snakefile</code>, we can run the following from the directory in which the Snakefile resides:</p>
<pre><code>snakemake --dag | dot -Tsvg &gt; dag.svg</code></pre>
<p>This will produce an image showing us exactly what steps Snakemake will during execution. This plot ignores the VCF calling steps, since the DAG gets pretty unweildy with that many steps!</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/tomsasani\.github\.io\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>